<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Input Selector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="audioInputSelect">Select Audio Input Device: </label>
        <select id="audioInputSelect"></select>
    </div>
    <div class="controls">
        <button id="audioToggle">Toggle Audio</button>
    </div>
    <div class="controls">
        <label for="gainControl">Master Gain: </label>
        <input type="range" id="gainControl" min="0" max="2" step="0.01" value="1">
    </div>

    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', async () => {
    const audioInputSelect = document.getElementById('audioInputSelect');
    const audioToggle = document.getElementById('audioToggle');
    const gainControl = document.getElementById('gainControl');

    let audioContext = null;
    let currentStream = null;
    let gainNode = null;
    let sourceNode = null;

    // Function to get and populate audio input devices
    async function getAudioInputDevices() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioInputDevices = devices.filter(device => device.kind === 'audioinput');

        audioInputDevices.forEach((device, index) => {
            const option = document.createElement('option');
            option.value = device.deviceId;
            option.textContent = device.label || `Microphone ${index + 1}`;
            audioInputSelect.appendChild(option);
        });
    }

    // Function to initialize audio context and nodes
    async function initializeAudioContext(deviceId = null) {
        if (audioContext) {
            audioContext.close();
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
        }
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Define audio constraints
        const audioConstraints = {
            audio: {
                autoGainControl: false,
                noiseSuppression: false,
                echoCancellation: false,
                sampleRate: 44100
            }
        };

        if (deviceId) {
            audioConstraints.audio.deviceId = { exact: deviceId };
        }

        currentStream = await navigator.mediaDevices.getUserMedia(audioConstraints);

        sourceNode = audioContext.createMediaStreamSource(currentStream);
        gainNode = audioContext.createGain();
        sourceNode.connect(gainNode);
        gainNode.connect(audioContext.destination);

        // Set initial gain value
        gainNode.gain.value = gainControl.value;

        // Listen for gain control changes
        gainControl.addEventListener('input', (event) => {
            gainNode.gain.value = event.target.value;
        });
    }

    // Function to handle audio toggle
    audioToggle.addEventListener('click', () => {
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        } else if (audioContext.state === 'running') {
            audioContext.suspend();
        }
    });

    // Listen for device select changes
    audioInputSelect.addEventListener('change', async (event) => {
        const deviceId = event.target.value;
        await initializeAudioContext(deviceId);
    });

    // Get initial device list and initialize audio context
    await getAudioInputDevices();
    await initializeAudioContext();
});
    </script>
</body>
</html>